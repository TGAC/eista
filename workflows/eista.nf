/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IMPORT MODULES / SUBWORKFLOWS / FUNCTIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

include { FASTQC                 } from '../modules/nf-core/fastqc/main'
include { MULTIQC                } from '../modules/nf-core/multiqc/main'
include { paramsSummaryMap       } from 'plugin/nf-validation'
include { paramsSummaryMultiqc   } from '../subworkflows/nf-core/utils_nfcore_pipeline'
include { softwareVersionsToYAML } from '../subworkflows/nf-core/utils_nfcore_pipeline'
include { methodsDescriptionText } from '../subworkflows/local/utils_nfcore_eista_pipeline'

include { VPT_SEGMENTATION } from '../modules/local/vpt_segmentation'
include { VPT_PARTITION } from '../modules/local/vpt_partition'
include { VPT_METADATA } from '../modules/local/vpt_metadata'
include { VPT_SUM_SIGNALS } from '../modules/local/vpt_sum_signals'
include { VPT_UPDATE_VZG } from '../modules/local/vpt_update_vzg'

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    RUN MAIN WORKFLOW
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

workflow EISTA {

    take:
    ch_samplesheet // channel: samplesheet read in from --input

    main:

    ch_versions = Channel.empty()
    ch_multiqc_files = Channel.empty()

    //
    // MODULE: Run FastQC
    //
    // FASTQC (
    //     ch_samplesheet
    // )
    // ch_multiqc_files = ch_multiqc_files.mix(FASTQC.out.zip.collect{it[1]})
    // ch_versions = ch_versions.mix(FASTQC.out.versions.first())



    //===================================== Primary anaysis stage =====================================

    if (params.run_analyses.contains('primary')){

        if (params.technology == "vizgen") {
            if (!params.skip_analyses.contains('segmentation_partition_metadata')) {
                VPT_SEGMENTATION (
                    ch_samplesheet,
                    // Channel.fromPath(params.input)
                    // MTX_CONVERSION.out.h5ad
                )
                ch_versions = ch_versions.mix(VPT_SEGMENTATION.out.versions)
                ch_parquet = VPT_SEGMENTATION.out.parquet 

                VPT_PARTITION (
                    ch_samplesheet,
                    ch_parquet,
                )
                ch_versions = ch_versions.mix(VPT_PARTITION.out.versions)
                ch_counts = VPT_PARTITION.out.counts

                VPT_METADATA (
                    ch_parquet,
                    ch_counts,
                )
                ch_versions = ch_versions.mix(VPT_METADATA.out.versions)
                ch_metadata = VPT_METADATA.out.metadata

            }

            if (!params.skip_analyses.contains('sum_signals')) {
                VPT_SUM_SIGNALS (
                    ch_samplesheet,
                    ch_parquet,
                )
                ch_versions = ch_versions.mix(VPT_SUM_SIGNALS.out.versions)
                ch_signals = VPT_SUM_SIGNALS.out.signals
            }

            if (!params.skip_analyses.contains('update_vzg')) {
                VPT_UPDATE_VZG (
                    ch_samplesheet,
                    ch_parquet,
                    ch_counts,
                    ch_metadata,
                )
                ch_versions = ch_versions.mix(VPT_UPDATE_VZG.out.versions)
                // ch_vzg = VPT_UPDATE_VZG.out.vzg
            }

        }

    }


    if (params.run_analyses.contains('secondary')){
    
        // MODULE: Run QC and cell filtering
        ch_h5ad = Channel.empty()
        if(params.run_analyses.contains('primary')){
            ch_h5ad = MTX_CONVERSION.out.h5ad
        }else if(params.h5ad){
            ch_h5ad = Channel.fromPath(params.h5ad)
        }else if(params.aligner){
            path = [
                'kallisto': "${params.outdir}/kallisto/mtx_conversions/combined_*_matrix.h5ad",
                'alevin': "${params.outdir}/alevin/mtx_conversions/combined_*_matrix.h5ad",
                'star': "${params.outdir}/star/mtx_conversions/combined_raw_matrix.h5ad"
            ].get(params.aligner)
            ch_h5ad = Channel.fromPath(path)
        }else{
            log.warn("For this analysis, please specify an h5ad file either by setting --aligner for the " +
            "h5ad file generated by the aligner or by setting --h5ad for an existing h5ad file.")
            return
        }

        if (!params.skip_analyses.contains('qccellfilter')) {
            QC_CELL_FILTER (
                ch_h5ad,
                Channel.fromPath(params.input)
                // MTX_CONVERSION.out.h5ad
            )
            // ch_multiqc_files = ch_multiqc_files.mix(FASTQC.out.zip.collect{it[1]})
            ch_versions = ch_versions.mix(QC_CELL_FILTER.out.versions)
            ch_h5ad = QC_CELL_FILTER.out.h5ad         
        }
        
        // if (!params.skip_analyses.contains('clustering')) {
        //     CLUSTERING_ANALYSIS (
        //         ch_h5ad
        //     )
        //     ch_versions = ch_versions.mix(CLUSTERING_ANALYSIS.out.versions)
        // }   
        
    }
















    //
    // Collate and save software versions
    //
    softwareVersionsToYAML(ch_versions)
        .collectFile(
            storeDir: "${params.outdir}/pipeline_info",
            name: 'nf_core_pipeline_software_mqc_versions.yml',
            sort: true,
            newLine: true
        ).set { ch_collated_versions }

    //
    // MODULE: MultiQC
    //
    ch_multiqc_config        = Channel.fromPath(
        "$projectDir/assets/multiqc_config.yml", checkIfExists: true)
    ch_multiqc_custom_config = params.multiqc_config ?
        Channel.fromPath(params.multiqc_config, checkIfExists: true) :
        Channel.empty()
    ch_multiqc_logo          = params.multiqc_logo ?
        Channel.fromPath(params.multiqc_logo, checkIfExists: true) :
        Channel.empty()

    summary_params      = paramsSummaryMap(
        workflow, parameters_schema: "nextflow_schema.json")
    ch_workflow_summary = Channel.value(paramsSummaryMultiqc(summary_params))

    ch_multiqc_custom_methods_description = params.multiqc_methods_description ?
        file(params.multiqc_methods_description, checkIfExists: true) :
        file("$projectDir/assets/methods_description_template.yml", checkIfExists: true)
    ch_methods_description                = Channel.value(
        methodsDescriptionText(ch_multiqc_custom_methods_description))

    ch_multiqc_files = ch_multiqc_files.mix(
        ch_workflow_summary.collectFile(name: 'workflow_summary_mqc.yaml'))
    ch_multiqc_files = ch_multiqc_files.mix(ch_collated_versions)
    ch_multiqc_files = ch_multiqc_files.mix(
        ch_methods_description.collectFile(
            name: 'methods_description_mqc.yaml',
            sort: true
        )
    )

    MULTIQC (
        ch_multiqc_files.collect(),
        ch_multiqc_config.toList(),
        ch_multiqc_custom_config.toList(),
        ch_multiqc_logo.toList()
    )

    emit:
    multiqc_report = MULTIQC.out.report.toList() // channel: /path/to/multiqc_report.html
    versions       = ch_versions                 // channel: [ path(versions.yml) ]
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    THE END
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/
